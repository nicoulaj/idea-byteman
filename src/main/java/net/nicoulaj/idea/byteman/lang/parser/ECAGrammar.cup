eca_rule
	::=	eca:rule {: RESULT = rule; :}
	| ca:rule  {: RESULT = rule; :}

eca
::=	BIND event:e
		IF condition:c
		DO actions:a {: RESULT = node(ParseNode.BIND, eleft, eright, e, c, a); :}

ca
::=	IF condition:c
		DO actions:a {: RESULT = node(ParseNode.BIND, cleft, cright, null, c, a); :}

event
  ::=	NOTHING:n {: RESULT = node(ParseNode.NOTHING, nleft, nright); :}
	|	bindings:b {: RESULT = b; :}

bindings
	::=	binding:b COMMA bindings:bs {: RESULT = node(ParseNode.COMMA, bleft, bright, b, bs); :}
	|	binding:b SEMI bindings:bs {: RESULT = node(ParseNode.COMMA, bleft, bright, b, bs); :}
	|	binding:b SEMI {: RESULT = b; :}
	|	binding:b {: RESULT = b; :}

binding	::=	bind_sym:s ASSIGN expr:e {: RESULT = node(ParseNode.ASSIGN, sleft, sright, s, e); :}

bind_sym
	::=	simple_name:var COLON typename:type {: RESULT = node(ParseNode.COLON, varleft, varright, var, type); :}
	|	simple_name:var {: RESULT = var; :}

typename
    ::= name:t arraydims:d
    | name:t {: RESULT = t; :}

arraydims
    ::= LSQUARE RSQUARE arraydims:a {: RESULT = a + 1; :}
    |   LSQUARE RSQUARE  {: RESULT =  1; :}

condition
	::=	expr:e {: RESULT = e; :}

actions
  ::=	NOTHING:n {: RESULT = node(ParseNode.NOTHING, nleft, nright); :}
	|	action_expr_list:ael {: RESULT = ael; :}

action_expr_list
	::=	expr:e SEMI action_expr_list:ael
	|	expr:e COMMA action_expr_list:ael
	|	action_expr:ae {: RESULT = ae; :}

action_expr
	::=	expr:e {: RESULT = e; :}
	| expr:e SEMI {: RESULT = e; :}
	| throw_return_expr:tre {: RESULT = tre; :}
	| throw_return_expr:tre SEMI {: RESULT = tre; :}

throw_return_expr
    ::=	RETURN:r
	|	RETURN:r expr:e
	|	THROW name:i LPAREN RPAREN
	|	THROW name:i LPAREN expr_list:args RPAREN
	|	THROW NEW name:i LPAREN RPAREN
	|	THROW NEW name:i LPAREN expr_list:args RPAREN

expr_list
	::=	expr:e {: RESULT = e; :}
	|   expr:e COMMA expr_list:el
	|	expr:e SEMI expr_list:el
	|	error:err SEMI expr_list:el

expr
  ::= ternary_oper_expr:e
  |	binary_oper_expr:e
	|	unary_oper_expr:e
	|	array_expr:e
	|	field_expr:e
	|	meth_expr:e
	| new_expr:ne
	|	simple_expr:e
	| null_expr:e
	|	simple_name:n
	| simple_name:s ASSIGN expr:e
	| DOLLAR:d      ASSIGN expr:e
	| field_expr:f  ASSIGN expr:e
	| array_expr:a  ASSIGN expr:e

ternary_oper_expr
	::=	expr:cond TERN_IF expr:iftrue COLON expr:iffalse

binary_oper_expr
	// logical operators
	::=	expr:e1 OR:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.OR, oleft, oright), e1, e2); :}
	|	expr:e1 AND:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.AND, oleft, oright), e1, e2); :}
	// comparison operators
	|	expr:e1 LT:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.LT, oleft, oright), e1, e2); :}
	|	expr:e1 LE:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.LE, oleft, oright), e1, e2); :}
	|	expr:e1 EQ:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.EQ, oleft, oright), e1, e2); :}
	|	expr:e1 NE:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.NE, oleft, oright), e1, e2); :}
	|	expr:e1 GE:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.GE, oleft, oright), e1, e2); :}
	|	expr:e1 GT:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.GT, oleft, oright), e1, e2); :}
	// bitwise operators
	|	expr:e1 BOR:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.BOR, oleft, oright), e1, e2); :}
	|	expr:e1 BAND:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.BAND, oleft, oright), e1, e2); :}
	|	expr:e1 BXOR:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.BXOR, oleft, oright), e1, e2); :}
	// arithmetic operators
	| expr:e1 PLUS:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.PLUS, oleft, oright), e1, e2); :}
	|	expr:e1 MINUS:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.MINUS, oleft, oright), e1, e2); :}
	|	expr:e1 MUL:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.MUL, oleft, oright), e1, e2); :}
	|	expr:e1 DIV:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.DIV, oleft, oright), e1, e2); :}
	|	expr:e1 MOD:o expr:e2 {: RESULT = node(ParseNode.BINOP, e1left, e1right, node(ParseNode.MOD, oleft, oright), e1, e2); :}

unary_oper_expr
	/* logical operators */
	::=	NOT:o expr:e {: RESULT = node(ParseNode.UNOP, eleft, eright, node(ParseNode.NOT, oleft, oright), e); :}
	/* bitwise operators */
	|	TWIDDLE:o expr:e {: RESULT = node(ParseNode.UNOP, eleft, eright, node(ParseNode.TWIDDLE, oleft, oright), e); :}
	/* arithmetic operators */
    |   MINUS:o expr:e {: RESULT = node(ParseNode.UNOP, eleft, eright, node(ParseNode.UMINUS, oleft, oright), e); :} %prec UMINUS
	;

array_expr
	::=	simple_expr:se array_idx_list:ail
	|	simple_name:name array_idx_list:ail
	|	field_expr:fe array_idx_list:ail
	|	meth_expr:me array_idx_list:ail

array_idx_list
	::=	array_idx:ai array_idx_list:ail
	|   array_idx:ai {: RESULT = ai; :}

array_idx
	::=	LSQUARE expr:e RSQUARE {: RESULT = e; :}

field_expr
	::=	path:p DOT simple_name:f
	|	expr_field_expr:efe {: RESULT = efe; :}

expr_field_expr
	::=	simple_expr:se      DOT simple_name:f
	 |	meth_expr:me        DOT simple_name:f
	 |	expr_field_expr:efe DOT simple_name:f

meth_expr
	::=	simple_name:m            LPAREN                RPAREN
	  |	simple_name:m            LPAREN expr_list:args RPAREN
	  |	path:p DOT simple_name:m LPAREN                RPAREN
	  |	path:p DOT simple_name:m LPAREN expr_list:args RPAREN
	  |	expr_meth_expr:eme
	;

expr_meth_expr
	::=	simple_expr:se    DOT simple_name:m LPAREN                RPAREN
	|	simple_expr:se      DOT simple_name:m LPAREN expr_list:args RPAREN
	|	meth_expr:eme       DOT simple_name:m LPAREN                RPAREN
	|	meth_expr:eme       DOT simple_name:m LPAREN expr_list:args RPAREN
	|	expr_field_expr:efe DOT simple_name:m LPAREN                RPAREN
	|	expr_field_expr:efe DOT simple_name:m LPAREN expr_list:args RPAREN

new_expr
::=	NEW name:i LPAREN                RPAREN
	|	NEW name:i new_array_idx_list:as
	|	NEW name:i LPAREN expr_list:args RPAREN

new_array_idx_list
    ::= LSQUARE:l RSQUARE
    |   LSQUARE expr:e RSQUARE
    |   LSQUARE:l RSQUARE new_array_idx_list:as
    |   LSQUARE expr:e RSQUARE new_array_idx_list:as
    ;

simple_expr
	::=	INTEGER_LITERAL:i
	|	FLOAT_LITERAL:f
	|	BOOLEAN_LITERAL:b
	|	STRING_LITERAL:s
	|	DOLLAR:s
	|	LPAREN expr:e RPAREN

null_expr
    ::=	NULL_LITERAL:n

name
  ::=	simple_name:n
	|	path:p DOT IDENTIFIER:i

simple_name
	::=	IDENTIFIER:i

path
  ::=	IDENTIFIER:i
	|	path:p DOT IDENTIFIER:i
