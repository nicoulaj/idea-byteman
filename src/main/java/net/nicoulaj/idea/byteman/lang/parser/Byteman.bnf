/*
 * Copyright (c) 2011-2012 Julien Nicoulaud <julien.nicoulaud@gmail.com>
 *
 * This file is part of idea-byteman.
 *
 * idea-byteman is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * idea-byteman is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with idea-byteman.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Parser grammar definition for Byteman.
 * <p/>
 * Derived from Byteman project's <code>ECAGrammar.cup</code> and source code.
 *
 * @author <a href="mailto:julien.nicoulaud@gmail.com">Julien Nicoulaud</a>
 * @since 0.1
 */
{
  parserClass="net.nicoulaj.idea.byteman.lang.parser.BytemanParser"
  stubParserClass="net.nicoulaj.idea.byteman.lang.parser.BytemanParserUtil"
  implements="net.nicoulaj.idea.byteman.lang.psi.BytemanPsiElement"
  extends="net.nicoulaj.idea.byteman.lang.psi.impl.BytemanPsiElementImpl"
  psiClassPrefix="Byteman"
  psiImplClassSuffix="Impl"
  psiPackage="net.nicoulaj.idea.byteman.lang.psi"
  psiImplPackage="net.nicoulaj.idea.byteman.lang.psi.impl"
  elementTypeHolderClass="net.nicoulaj.idea.byteman.lang.BytemanTypes"
  elementTypePrefix=""
  elementTypeClass="net.nicoulaj.idea.byteman.lang.psi.BytemanElementType"
  tokenTypeClass="net.nicoulaj.idea.byteman.lang.lexer.BytemanTokenType"
}

script ::=
  (COMMENT|helper|rule)*

helper ::=
  KEYWORD_HELPER CLASS_REF

rule ::=
  KEYWORD_RULE RULE_NAME
  helper?
  KEYWORD_CLASS OVERRIDE? CLASS_REF
  KEYWORD_METHOD METHOD_REF
  location?
  (KEYWORD_BIND event)?
  KEYWORD_IF condition
  KEYWORD_DO actions
  KEYWORD_ENDRULE
  { implements="net.nicoulaj.idea.byteman.lang.psi.BytemanPsiNamedElement"
    mixin="net.nicoulaj.idea.byteman.lang.psi.impl.BytemanRuleBase" }

location ::=
   entry_location
 | line_location
 | read_location
 | write_location
 | invoke_location
 | synchronize_location
 | throw_location
 | exit_location

entry_location ::=
  KEYWORD_AT KEYWORD_ENTRY
  { extends="location" }

line_location ::=
  KEYWORD_AT? KEYWORD_LINE INTEGER_LITERAL
  { extends="location" }

read_location ::=
  (KEYWORD_AT|KEYWORD_AFTER) KEYWORD_READ path (INTEGER_LITERAL|KEYWORD_ALL)?
  { extends="location" }

write_location ::=
  (KEYWORD_AT|KEYWORD_AFTER) KEYWORD_WRITE path (INTEGER_LITERAL|KEYWORD_ALL)?
  { extends="location" }

invoke_location ::=
  (KEYWORD_AT|KEYWORD_AFTER) KEYWORD_INVOKE path LPAREN identifier_expr* RPAREN (INTEGER_LITERAL|KEYWORD_ALL)?
  { extends="location" }

synchronize_location ::=
  (KEYWORD_AT|KEYWORD_AFTER) KEYWORD_SYNCHRONIZE (INTEGER_LITERAL|KEYWORD_ALL)?
  { extends="location" }

throw_location ::=
  KEYWORD_AT KEYWORD_THROW identifier_expr? (INTEGER_LITERAL|KEYWORD_ALL)?
  { extends="location" }

exit_location ::=
  KEYWORD_AT KEYWORD_RETURN
  { extends="location" }

event ::=
  nothing_event | binding_event

nothing_event ::=
  KEYWORD_NOTHING
  { extends="event" }

binding_event ::=
  (binding (COMMA|SEMI))* binding SEMI?
  { extends="event" }

binding ::=
  binding_symbol ASSIGN expr

binding_symbol ::=
  identifier_expr (COLON type_name)?

type_name ::=
  path array_dimensions?

array_dimensions ::=
  (LSQUARE RSQUARE)+

condition ::=
  expr

actions ::=
  nothing_actions | expr_actions

nothing_actions ::=
  KEYWORD_NOTHING
  { extends="actions" }

expr_actions ::=
  (expr (SEMI|COMMA))* (expr | throw_return_expr) SEMI?
  { extends="actions" }

throw_return_expr ::=
  throw_expr | return_expr

throw_expr ::=
  KEYWORD_THROW KEYWORD_NEW? path LPAREN expr_list? RPAREN
  { extends="throw_return_expr" }

expr_list ::=
  (expr (SEMI|COMMA))* expr

return_expr ::=
  KEYWORD_RETURN expr?
  { extends="throw_return_expr" }

expr ::=
  base_expr | binary_expr | ternary_expr

binary_expr ::=
  (base_expr (OR|AND|LT|LE|EQ|NE|GE|GT|URSH|RSH|LSH|BOR|BAND|BXOR|PLUS|MINUS|MUL|DIV|MOD) expr)+
  { extends="expr" }

ternary_expr ::=
  (base_expr TERN_IF expr COLON expr)+
  { extends="expr" }

base_expr ::=
    unary_oper_expr
  | array_expr
  | field_expr
  | meth_expr
  | new_expr
  | simple_expr
  | null_expr
  | identifier_expr
  | assign_expr

unary_oper_expr ::=
  (NOT|TWIDDLE|MINUS) expr
  { extends="base_expr" }

array_expr ::=
  (simple_expr|identifier_expr|field_expr|meth_expr) (LSQUARE expr RSQUARE)+
  { extends="base_expr" }

field_expr ::=
    path DOT identifier_expr
  | (simple_expr|meth_expr) (DOT identifier_expr)+
  { extends="base_expr" }

meth_expr ::=
  ( ((path|simple_expr) DOT)* identifier_expr LPAREN expr_list? RPAREN )+
  { extends="base_expr" }

new_expr ::=
  KEYWORD_NEW path ( new_array_idx_list | LPAREN expr_list? RPAREN )
  { extends="base_expr" }

new_array_idx_list ::=
  (LSQUARE expr? RSQUARE)+

assign_expr ::=
  (identifier_expr|DOLLAR|field_expr|array_expr) ASSIGN expr
  { extends="base_expr" }

simple_expr ::=
    INTEGER_LITERAL
  | FLOAT_LITERAL
  | BOOLEAN_LITERAL
  | STRING_LITERAL
  | DOLLAR
  | LPAREN expr RPAREN
  { extends="base_expr" }

null_expr ::=
  NULL_LITERAL
  { extends="base_expr" }

identifier_expr ::=
  IDENTIFIER
  { extends="base_expr" }

path ::=
  (identifier_expr DOT)* identifier_expr
